Суть моего решения состоит в том, чтобы, для определения списывания,
рассмотреть изменения в общей структуре кода, а не изменения в названиях переменных или функицй.
Ведь в ходе копирования именно их и меняет ленивый студент, стараясь избежать подозрений.
Структуру кода при этом он меняет мало: удаляет или вставляет компоненты, меняет их местами.
Поэтому в моем решении используется измененный алгоритм Левенштайна, позволяющий учесть перестановку
cоседей двух последовательностей ([*алг. Дамерау — Левенштейна*](https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%81%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5_%D0%94%D0%B0%D0%BC%D0%B5%D1%80%D0%B0%D1%83_%E2%80%94_%D0%9B%D0%B5%D0%B2%D0%B5%D0%BD%D1%88%D1%82%D0%B5%D0%B9%D0%BD%D0%B0)).

Конечный балл (score) выставляется по формуле:

**1 - Расстояние/max(Длина первой последовательности, Длина второй последовательности)**

При данном виде формулы, работы со **score > 0.6** я бы подозревал в списывании.

Конечно же вид формулы можно и усложнить, чтобы более баллы точно описывали присутстсвие копирования.


